import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ForbiddenException,
  UnauthorizedException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { DigitalSignatureService, SignatureMetadata } from './digital-signature.service';
import { UploadCertificateDto } from './dto/upload-certificate.dto';
import { SignDocumentDto } from './dto/sign-document.dto';
import { CreateSignatureRequirementDto } from './dto/create-signature-requirement.dto';
import { join } from 'path';
import { readFileSync } from 'fs';
import * as bcrypt from 'bcrypt';

@Injectable()
export class SignaturesService {
  constructor(
    private prisma: PrismaService,
    private digitalSignatureService: DigitalSignatureService,
  ) {}

  /**
   * Upload e armazenamento de certificado A1
   */
  async uploadCertificate(
    userId: string,
    certificateFile: Express.Multer.File,
    dto: UploadCertificateDto,
  ) {
    // Validar senha do usuário (opcional, para segurança extra)
    if (dto.userPassword) {
      const user = await this.prisma.user.findUnique({ where: { id: userId } });
      const isValid = await bcrypt.compare(dto.userPassword, user.password);
      if (!isValid) {
        throw new UnauthorizedException('Senha do usuário incorreta');
      }
    }

    // Ler dados do certificado
    const certificateData = certificateFile.buffer;

    // Validar e extrair informações do certificado
    const certInfo = this.digitalSignatureService.parseCertificate(
      certificateData,
      dto.password,
    );

    this.digitalSignatureService.validateCertificate(certificateData, dto.password);

    // Verificar se certificado já está cadastrado
    const existing = await this.prisma.userCertificate.findFirst({
      where: {
        userId,
        serialNumber: certInfo.serialNumber,
        isActive: true,
      },
    });

    if (existing) {
      throw new BadRequestException('Este certificado já está cadastrado');
    }

    // Criptografar dados do certificado para armazenamento
    const encryptionKey = process.env.CERTIFICATE_ENCRYPTION_KEY || 'default-key-change-me';
    const encryptedData = this.digitalSignatureService.encryptCertificateData(
      certificateData,
      encryptionKey,
    );

    // Criptografar senha do certificado
    const encryptedPassword = this.digitalSignatureService.encryptCertificateData(
      Buffer.from(dto.password),
      encryptionKey,
    );

    // Se for marcado como padrão, desmarcar outros
    if (dto.isDefault) {
      await this.prisma.userCertificate.updateMany({
        where: { userId, isDefault: true },
        data: { isDefault: false },
      });
    }

    // Salvar no banco
    const certificate = await this.prisma.userCertificate.create({
      data: {
        userId,
        name: dto.name,
        type: 'A1',
        certificateData: encryptedData,
        certificatePassword: encryptedPassword,
        subject: certInfo.subject,
        issuer: certInfo.issuer,
        serialNumber: certInfo.serialNumber,
        validFrom: certInfo.validFrom,
        validTo: certInfo.validTo,
        cpf: certInfo.cpf,
        cnpj: certInfo.cnpj,
        isDefault: dto.isDefault || false,
      },
    });

    return {
      id: certificate.id,
      name: certificate.name,
      subject: certificate.subject,
      cpf: certificate.cpf,
      cnpj: certificate.cnpj,
      validFrom: certificate.validFrom,
      validTo: certificate.validTo,
      isDefault: certificate.isDefault,
    };
  }

  /**
   * Lista certificados do usuário
   */
  async getMyCertificates(userId: string) {
    const certificates = await this.prisma.userCertificate.findMany({
      where: { userId, isActive: true },
      select: {
        id: true,
        name: true,
        type: true,
        subject: true,
        issuer: true,
        serialNumber: true,
        validFrom: true,
        validTo: true,
        cpf: true,
        cnpj: true,
        isDefault: true,
        createdAt: true,
      },
      orderBy: { createdAt: 'desc' },
    });

    return certificates.map(cert => ({
      ...cert,
      isExpired: new Date() > cert.validTo,
      daysUntilExpiration: Math.ceil(
        (cert.validTo.getTime() - Date.now()) / (1000 * 60 * 60 * 24),
      ),
    }));
  }

  /**
   * Assina um documento
   */
  async signDocument(userId: string, dto: SignDocumentDto) {
    // Buscar anexo
    const attachment = await this.prisma.attachment.findUnique({
      where: { id: dto.attachmentId },
      include: {
        stepExecution: {
          include: {
            stepVersion: {
              include: {
                signatureRequirements: {
                  include: {
                    signatureRecords: true,
                    user: { select: { id: true, name: true, email: true } },
                    sector: { select: { id: true, name: true } },
                  },
                  orderBy: { order: 'asc' },
                },
              },
            },
            processInstance: {
              include: {
                createdBy: { select: { id: true, name: true } },
              },
            },
          },
        },
      },
    });

    if (!attachment) {
      throw new NotFoundException('Anexo não encontrado');
    }

    // Verificar se etapa requer assinatura
    if (!attachment.stepExecution.stepVersion.requiresSignature) {
      throw new BadRequestException('Esta etapa não requer assinatura');
    }

    // Verificar se anexo é PDF
    if (attachment.mimeType !== 'application/pdf') {
      throw new BadRequestException('Apenas arquivos PDF podem ser assinados');
    }

    // Buscar certificado do usuário
    const certificate = dto.certificateId
      ? await this.prisma.userCertificate.findFirst({
          where: { id: dto.certificateId, userId, isActive: true },
        })
      : await this.prisma.userCertificate.findFirst({
          where: { userId, isActive: true, isDefault: true },
        });

    if (!certificate) {
      throw new BadRequestException(
        'Certificado não encontrado. Faça upload de um certificado A1',
      );
    }

    // Verificar validade do certificado
    if (new Date() > certificate.validTo) {
      throw new BadRequestException('Certificado expirado');
    }

    // Descriptografar dados do certificado
    const encryptionKey = process.env.CERTIFICATE_ENCRYPTION_KEY || 'default-key-change-me';
    const certificateData = this.digitalSignatureService.decryptCertificateData(
      certificate.certificateData,
      encryptionKey,
    );

    // Validar senha do certificado
    try {
      this.digitalSignatureService.validateCertificate(
        certificateData,
        dto.certificatePassword,
      );
    } catch (error) {
      throw new BadRequestException('Senha do certificado incorreta');
    }

    // Encontrar requirement correspondente
    const requirements = attachment.stepExecution.stepVersion.signatureRequirements;

    let requirement = requirements.find(
      r => r.userId === userId || r.sectorId != null,
    );

    // Se não encontrou requirement específico, criar um temporário
    if (!requirement) {
      // Verificar se usuário tem permissão genérica para assinar
      const userCompany = await this.prisma.userCompany.findFirst({
        where: {
          userId,
          companyId: attachment.stepExecution.processInstance.companyId,
        },
      });

      if (!userCompany) {
        throw new ForbiddenException('Sem permissão para assinar este documento');
      }

      // Criar requirement on-the-fly
      requirement = await this.prisma.signatureRequirement.create({
        data: {
          stepVersionId: attachment.stepExecution.stepVersionId,
          order: requirements.length + 1,
          type: 'PARALLEL',
          userId,
          isRequired: false,
        },
        include: {
          signatureRecords: true,
        },
      });
    }

    // Verificar se já assinou
    const existingSignature = await this.prisma.signatureRecord.findFirst({
      where: {
        requirementId: requirement.id,
        signerId: userId,
        attachmentId: dto.attachmentId,
      },
    });

    if (existingSignature) {
      throw new BadRequestException('Você já assinou este documento');
    }

    // Verificar ordem de assinatura (se SEQUENTIAL)
    if (requirement.type === 'SEQUENTIAL') {
      const previousRequirements = requirements.filter(r => r.order < requirement.order);
      for (const prevReq of previousRequirements) {
        const prevSignature = prevReq.signatureRecords.find(
          s => s.status === 'COMPLETED',
        );
        if (!prevSignature) {
          throw new BadRequestException(
            `Aguardando assinatura de ${prevReq.user?.name || prevReq.sector?.name} (ordem ${prevReq.order})`,
          );
        }
      }
    }

    // Preparar metadados
    const metadata: SignatureMetadata = {
      signer: {
        name: certificate.subject.split('CN=')[1]?.split(',')[0] || 'Assinante',
        cpf: certificate.cpf,
        cnpj: certificate.cnpj,
      },
      reason: dto.reason || 'Assinatura Digital',
      location: dto.location,
      contactInfo: dto.contactInfo,
    };

    // Assinar PDF
    const signedFilename = `signed-${Date.now()}-${attachment.filename}`;
    const signedPath = join(process.cwd(), 'uploads', 'signatures', signedFilename);

    const signatureResult = await this.digitalSignatureService.signPDF(
      attachment.path,
      signedPath,
      certificateData,
      dto.certificatePassword,
      metadata,
    );

    // Criar registro de assinatura
    const signatureRecord = await this.prisma.signatureRecord.create({
      data: {
        requirementId: requirement.id,
        attachmentId: dto.attachmentId,
        signerId: userId,
        stepExecutionId: dto.stepExecutionId,
        status: 'COMPLETED',
        certificateType: 'A1',
        certificateSubject: certificate.subject,
        certificateIssuer: certificate.issuer,
        certificateSerialNumber: certificate.serialNumber,
        certificateValidFrom: certificate.validFrom,
        certificateValidTo: certificate.validTo,
        certificateCPF: certificate.cpf,
        certificateCNPJ: certificate.cnpj,
        signedAt: new Date(),
        signatureHash: signatureResult.signatureHash,
        signatureAlgorithm: signatureResult.algorithm,
        signatureReason: dto.reason,
        signatureLocation: dto.location,
        ipAddress: dto.ipAddress,
        userAgent: dto.userAgent,
        geolocation: dto.geolocation,
        metadata: {
          contactInfo: dto.contactInfo,
        },
      },
      include: {
        signer: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        requirement: true,
      },
    });

    // Atualizar anexo
    await this.prisma.attachment.update({
      where: { id: dto.attachmentId },
      data: {
        isSigned: true,
        signedPath: signatureResult.signedPath,
      },
    });

    // Verificar se todas as assinaturas requeridas foram concluídas
    const allRequirements = await this.prisma.signatureRequirement.findMany({
      where: {
        stepVersionId: attachment.stepExecution.stepVersionId,
        isRequired: true,
      },
      include: {
        signatureRecords: {
          where: {
            attachmentId: dto.attachmentId,
            status: 'COMPLETED',
          },
        },
      },
    });

    const allSigned = allRequirements.every(req => req.signatureRecords.length > 0);

    if (allSigned) {
      // Marcar step execution como assinado
      await this.prisma.stepExecution.update({
        where: { id: dto.stepExecutionId },
        data: { signedAt: new Date() },
      });
    }

    return {
      success: true,
      signatureRecord,
      signedPath: signatureResult.signedPath,
      allRequirementsMet: allSigned,
    };
  }

  /**
   * Cria requisito de assinatura para uma etapa
   */
  async createSignatureRequirement(dto: CreateSignatureRequirementDto) {
    // Validar que userId OU sectorId está preenchido
    if (!dto.userId && !dto.sectorId) {
      throw new BadRequestException(
        'Informe userId ou sectorId para o assinante',
      );
    }

    // Verificar se etapa existe
    const stepVersion = await this.prisma.stepVersion.findUnique({
      where: { id: dto.stepVersionId },
    });

    if (!stepVersion) {
      throw new NotFoundException('Etapa não encontrada');
    }

    // Verificar se ordem já existe
    const existing = await this.prisma.signatureRequirement.findUnique({
      where: {
        stepVersionId_order: {
          stepVersionId: dto.stepVersionId,
          order: dto.order,
        },
      },
    });

    if (existing) {
      throw new BadRequestException(
        `Já existe um requisito com ordem ${dto.order}`,
      );
    }

    // Criar requirement
    const requirement = await this.prisma.signatureRequirement.create({
      data: {
        stepVersionId: dto.stepVersionId,
        order: dto.order,
        type: dto.type,
        isRequired: dto.isRequired ?? true,
        description: dto.description,
        userId: dto.userId,
        sectorId: dto.sectorId,
        attachmentId: dto.attachmentId,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        sector: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    return requirement;
  }

  /**
   * Lista requisitos de assinatura de uma etapa
   */
  async getSignatureRequirements(stepVersionId: string) {
    return this.prisma.signatureRequirement.findMany({
      where: { stepVersionId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        sector: {
          select: {
            id: true,
            name: true,
          },
        },
        signatureRecords: {
          include: {
            signer: {
              select: {
                id: true,
                name: true,
                email: true,
              },
            },
          },
        },
      },
      orderBy: { order: 'asc' },
    });
  }

  /**
   * Lista assinaturas de um anexo
   */
  async getAttachmentSignatures(attachmentId: string) {
    return this.prisma.signatureRecord.findMany({
      where: { attachmentId },
      include: {
        signer: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        requirement: {
          select: {
            order: true,
            type: true,
            description: true,
          },
        },
      },
      orderBy: { createdAt: 'asc' },
    });
  }

  /**
   * Verifica assinaturas de um PDF
   */
  async verifySignatures(attachmentId: string) {
    const attachment = await this.prisma.attachment.findUnique({
      where: { id: attachmentId },
    });

    if (!attachment) {
      throw new NotFoundException('Anexo não encontrado');
    }

    if (!attachment.signedPath) {
      throw new BadRequestException('Este anexo não possui assinaturas');
    }

    return this.digitalSignatureService.verifyPDFSignature(attachment.signedPath);
  }

  /**
   * Remove certificado do usuário
   */
  async deleteCertificate(userId: string, certificateId: string) {
    const certificate = await this.prisma.userCertificate.findFirst({
      where: { id: certificateId, userId },
    });

    if (!certificate) {
      throw new NotFoundException('Certificado não encontrado');
    }

    await this.prisma.userCertificate.update({
      where: { id: certificateId },
      data: { isActive: false },
    });

    return { success: true };
  }

  /**
   * Define certificado padrão
   */
  async setDefaultCertificate(userId: string, certificateId: string) {
    const certificate = await this.prisma.userCertificate.findFirst({
      where: { id: certificateId, userId, isActive: true },
    });

    if (!certificate) {
      throw new NotFoundException('Certificado não encontrado');
    }

    // Desmarcar outros
    await this.prisma.userCertificate.updateMany({
      where: { userId, isDefault: true },
      data: { isDefault: false },
    });

    // Marcar como padrão
    await this.prisma.userCertificate.update({
      where: { id: certificateId },
      data: { isDefault: true },
    });

    return { success: true };
  }
}
